unit SSPatternBuilder;

interface

uses
  System.RegularExpressions,
  System.SysUtils,
  System.StrUtils,
  System.Generics.Collections,
  System.Generics.Defaults;

type
  TSSPatternBuilder = record
    const
      Any             = '.';
      Letter          = '[A-Za-z]';
      Digit           = '[0-9]';
      UpperCaseLetter = '[A-Z]';
      LowerCaseLetter = '[a-z]';
    { Available functions }
    class function Group(aPattern: String; aIsPattern: Boolean = True): String; static;
    class function Optional(aPattern: String; aIsPattern: Boolean = True): String; static;
    class function Negate(aList: String; aIsPattern: Boolean = True): String; overload; static;
    class function Negate(aValues: array of Char; aIsPattern: Boolean = True): String; overload; static;
    class function List(aValues: array of Char; aIsPattern: Boolean = True): String; static;
    class function StartsWith(aPattern: String; aIsPattern: Boolean = True): String; static;
    class function EndsWith(aPattern: String; aIsPattern: Boolean = True): String; static;
    class function RepeatIt(aPattern: String; aMin, aMax: Integer; aIsPattern: Boolean = True): String; static;
  end;

implementation

  function Group(aPattern: String; aIsPattern: Boolean = True): String; forward;
  function CheckPattern(aValue: String; aIsPattern: Boolean = True): String; forward;
  function CheckGroup(aPattern: String; aIsPattern: Boolean = True): String; forward;

function CheckGroup(aPattern: String; aIsPattern: Boolean): String;
begin
  Result := CheckPattern(aPattern, aIsPattern);
  if not TRegEx.IsMatch(Result, '^\[.*\]$') then
    Result := Group(aPattern);
end;

function CheckPattern(aValue: String;
  aIsPattern: Boolean): String;
begin
  if aIsPattern then
    Result := aValue
  else
    Result := TRegEx.Replace(aValue, '(\.|\^|\$|\*|\+|\?|\(|\)|\[|\{|\\|\||\^|\-|\]|\\)', '\\\1');
end;

{ TSSPatternBuilder }

class function TSSPatternBuilder.EndsWith(aPattern: String;
  aIsPattern: Boolean): String;
begin
  Result := CheckPattern(aPattern, aIsPattern)+'$';
end;

class function TSSPatternBuilder.Group(aPattern: String; aIsPattern: Boolean): String;
begin
  Result := '('+CheckPattern(aPattern, aIsPattern)+')';
end;

class function TSSPatternBuilder.List(aValues: array of Char;
  aIsPattern: Boolean): String;

    function GetList: String;
    var
      Ch: Char;
    begin
      Result := '';
      for Ch in aValues do
        Result := Result + Ch;
    end;

begin
  Result := '['+GetList+']';
end;

class function TSSPatternBuilder.Negate(aValues: array of Char;
  aIsPattern: Boolean): String;
begin
  Result := Negate(List(aValues, aIsPattern), True);
end;

class function TSSPatternBuilder.Negate(aList: String;
  aIsPattern: Boolean): String;
begin
  Result := '^'+CheckPattern(aList, aIsPattern);
end;

class function TSSPatternBuilder.Optional(aPattern: String; aIsPattern: Boolean): String;
begin
  Result := CheckPattern(aPattern, aIsPattern)+'?';
end;

class function TSSPatternBuilder.RepeatIt(aPattern: String; aMin,
  aMax: Integer; aIsPattern: Boolean): String;
begin
  Result := CheckPattern(aPattern, aIsPattern)+'{'+IntToStr(aMin)+','+IntToStr(aMax)+'}';
end;

class function TSSPatternBuilder.StartsWith(aPattern: String;
  aIsPattern: Boolean): String;
begin
  Result := '^'+CheckPattern(aPattern, aIsPattern);
end;

end.
